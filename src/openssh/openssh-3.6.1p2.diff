diff -udrNP openssh-3.6.1p2.orig/Makefile.in openssh-3.6.1p2/Makefile.in
--- openssh-3.6.1p2.orig/Makefile.in	2003-04-29 11:12:08.000000000 +0200
+++ openssh-3.6.1p2/Makefile.in	2003-06-15 21:18:57.000000000 +0200
@@ -67,7 +67,7 @@
 	key.o dispatch.o kex.o mac.o uuencode.o misc.o \
 	rijndael.o ssh-dss.o ssh-rsa.o dh.o kexdh.o kexgex.o \
 	kexdhc.o kexgexc.o scard.o msg.o progressmeter.o \
-	entropy.o
+	entropy.o scard-opensc.o
 
 SSHOBJS= ssh.o readconf.o clientloop.o sshtty.o \
 	sshconnect.o sshconnect1.o sshconnect2.o
diff -udrNP openssh-3.6.1p2.orig/scard.c openssh-3.6.1p2/scard.c
--- openssh-3.6.1p2.orig/scard.c	2002-06-23 23:23:20.000000000 +0200
+++ openssh-3.6.1p2/scard.c	2003-07-23 12:19:29.000000000 +0200
@@ -35,6 +35,9 @@
 #include "readpass.h"
 #include "scard.h"
 
+/* currently unused */
+int ask_for_pin = 0;
+
 #if OPENSSL_VERSION_NUMBER < 0x00907000L
 #define USE_ENGINE
 #define RSA_get_default_method RSA_get_default_openssl_method
diff -udrNP openssh-3.6.1p2.orig/scard.h openssh-3.6.1p2/scard.h
--- openssh-3.6.1p2.orig/scard.h	2002-07-04 02:14:18.000000000 +0200
+++ openssh-3.6.1p2/scard.h	2003-07-23 12:18:46.000000000 +0200
@@ -33,6 +33,8 @@
 #define SCARD_ERROR_NOCARD	-2
 #define SCARD_ERROR_APPLET	-3
 
+extern int ask_for_pin;
+
 Key	**sc_get_keys(const char *, const char *);
 void	 sc_close(void);
 int	 sc_put_key(Key *, const char *);
diff -udrNP openssh-3.6.1p2.orig/scard-opensc.c openssh-3.6.1p2/scard-opensc.c
--- openssh-3.6.1p2.orig/scard-opensc.c	2002-04-23 14:48:46.000000000 +0200
+++ openssh-3.6.1p2/scard-opensc.c	2003-07-23 12:26:00.000000000 +0200
@@ -38,6 +38,8 @@
 #include "readpass.h"
 #include "scard.h"
 
+int ask_for_pin=0;
+
 #if OPENSSL_VERSION_NUMBER < 0x00907000L && defined(CRYPTO_LOCK_ENGINE)
 #define USE_ENGINE
 #define RSA_get_default_method RSA_get_default_openssl_method
@@ -89,6 +91,12 @@
 	r = sc_establish_context(&ctx, "openssh");
 	if (r)
 		goto err;
+	if (sc_reader_id >= ctx->reader_count) {
+		r=SC_ERROR_NO_READERS_FOUND;
+		error("Illegal reader number. Only %d reader(s) configured.\n",
+			ctx->reader_count);
+		goto err;
+	}
 	r = sc_connect_card(ctx->reader[sc_reader_id], 0, &card);
 	if (r)
 		goto err;
@@ -104,7 +112,8 @@
 /* private key operations */
 
 static int
-sc_prkey_op_init(RSA *rsa, struct sc_pkcs15_object **key_obj_out)
+sc_prkey_op_init(RSA *rsa, struct sc_pkcs15_object **key_obj_out,
+	unsigned int usage)
 {
 	int r;
 	struct sc_priv_data *priv;
@@ -124,7 +133,8 @@
 			goto err;
 		}
 	}
-	r = sc_pkcs15_find_prkey_by_id(p15card, &priv->cert_id, &key_obj);
+	r = sc_pkcs15_find_prkey_by_id_usage(p15card, &priv->cert_id, 
+		usage, &key_obj);
 	if (r) {
 		error("Unable to find private key from SmartCard: %s",
 		      sc_strerror(r));
@@ -133,12 +143,55 @@
 	key = key_obj->data;
 	r = sc_pkcs15_find_pin_by_auth_id(p15card, &key_obj->auth_id,
 					  &pin_obj);
-	if (r) {
+	if (r == SC_ERROR_OBJECT_NOT_FOUND)
+	{
+		/* no pin required */
+		r = sc_lock(card);
+		if (r) {
+			error("Unable to lock smartcard: %s", sc_strerror(r));
+			goto err;
+		}
+		*key_obj_out = key_obj;
+		return 0;
+	}
+	else if (r) {
+		/* some other OpenSC internal error */
 		error("Unable to find PIN object from SmartCard: %s",
 		      sc_strerror(r));
 		goto err;
 	}
 	pin = pin_obj->data;
+
+	if ((pin->auth_id.len > 0) && (! sc_pin) && ask_for_pin) {
+		/* we need a pin, we don't have one. let's ask. */
+		char *passphrase;
+
+		passphrase = read_passphrase("Enter passphrase for key:", 0);
+		if (! passphrase)
+			goto err;
+		if (strcmp(passphrase, "") == 0) 
+			goto err;
+		r = sc_lock(card);
+		if (r) {
+			error("Unable to lock smartcard: %s",
+					sc_strerror(r));
+			memset(passphrase, 0, strlen(passphrase));
+			xfree(passphrase);
+			goto err;
+		}
+		r = sc_pkcs15_verify_pin(p15card, pin, 
+			passphrase, strlen(passphrase));
+		memset(passphrase, 0, strlen(passphrase));
+		xfree(passphrase);
+		if (r) {
+			sc_unlock(card);
+			error("PIN code verification failed: %s",
+					sc_strerror(r));
+			goto err;
+		}
+		*key_obj_out = key_obj;
+		return 0;
+	}
 	r = sc_lock(card);
 	if (r) {
 		error("Unable to lock smartcard: %s", sc_strerror(r));
@@ -161,6 +214,9 @@
 	return -1;
 }
 
+#define SC_USAGE_DECRYPT	SC_PKCS15_PRKEY_USAGE_DECRYPT | \
+				SC_PKCS15_PRKEY_USAGE_UNWRAP
+
 static int
 sc_private_decrypt(int flen, u_char *from, u_char *to, RSA *rsa,
     int padding)
@@ -170,10 +226,11 @@
 
 	if (padding != RSA_PKCS1_PADDING)
 		return -1;	
-	r = sc_prkey_op_init(rsa, &key_obj);
+	r = sc_prkey_op_init(rsa, &key_obj, SC_USAGE_DECRYPT);
 	if (r)
 		return -1;
-	r = sc_pkcs15_decipher(p15card, key_obj, 0, from, flen, to, flen);
+	r = sc_pkcs15_decipher(p15card, key_obj, SC_ALGORITHM_RSA_PAD_PKCS1,
+				from, flen, to, flen);
 	sc_unlock(card);
 	if (r < 0) {
 		error("sc_pkcs15_decipher() failed: %s", sc_strerror(r));
@@ -185,6 +242,9 @@
 	return -1;
 }
 
+#define SC_USAGE_SIGN 		SC_PKCS15_PRKEY_USAGE_SIGN | \
+				SC_PKCS15_PRKEY_USAGE_SIGNRECOVER
+
 static int
 sc_sign(int type, u_char *m, unsigned int m_len,
 	unsigned char *sigret, unsigned int *siglen, RSA *rsa)
@@ -193,7 +253,15 @@
 	int r;
 	unsigned long flags = 0;
 
-	r = sc_prkey_op_init(rsa, &key_obj);
+	/* XXX: sc_prkey_op_init will search for a pkcs15 private
+	 * key object with the sign or signrecover usage flag set.
+	 * If the signing key has only the non-repudiation flag set
+	 * the key will be rejected as using a non-repudiation key
+	 * for authentication is not recommended. Note: This does not
+	 * prevent the use of a non-repudiation key for authentication
+	 * if the sign or signrecover flag is set as well. 
+	 */
+	r = sc_prkey_op_init(rsa, &key_obj, SC_USAGE_SIGN);
 	if (r)
 		return -1;
 	/* FIXME: length of sigret correct? */
@@ -423,9 +491,14 @@
 		}
 		key_count = r;
 	}
-	/* FIXME: only keep entries with a corresponding private key */
 	keys = xmalloc(sizeof(Key *) * (key_count*2+1));
 	for (i = 0; i < key_count; i++) {
+		sc_pkcs15_object_t *tmp_obj = NULL;
+		cert_id = ((sc_pkcs15_cert_info_t *)(certs[i]->data))->id;
+		if (sc_pkcs15_find_prkey_by_id(p15card, &cert_id, &tmp_obj))
+			/* skip the public key (certificate) if no
+			 * corresponding private key is present */
+			continue;
 		k = key_new(KEY_RSA);
 		if (k == NULL)
 			break;
diff -udrNP openssh-3.6.1p2.orig/ssh.c openssh-3.6.1p2/ssh.c
--- openssh-3.6.1p2.orig/ssh.c	2003-02-24 01:57:32.000000000 +0100
+++ openssh-3.6.1p2/ssh.c	2003-07-23 12:21:43.000000000 +0200
@@ -1172,6 +1172,9 @@
 #ifdef SMARTCARD
 	Key **keys;
 
+	if (!options.batch_mode)
+		ask_for_pin=1;
+
 	if (options.smartcard_device != NULL &&
 	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
 	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL ) {
